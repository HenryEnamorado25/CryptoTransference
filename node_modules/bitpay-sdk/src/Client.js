"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
var index_1 = require("./index");
var Model_1 = require("./Model");
var Refund_1 = require("./Model/Invoice/Refund");
var fs = require('fs');
/**
 * @author Antonio Buedo
 * @version 1.4.2102
 * See bitpay.com/api for more information.
 * date 19.02.2021
 */
var Client = /** @class */ (function () {
    function Client(configFilePath, environment, privateKey, tokens) {
        var _this = this;
        this._keyUtils = new index_1.KeyUtils();
        this.GetRates = function (currency) {
            if (currency === void 0) { currency = null; }
            return __awaiter(_this, void 0, void 0, function () {
                var uri, e_1;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            uri = currency ? "rates/" + currency : "rates";
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this._RESTcli.get(uri, null, false).then(function (ratesData) {
                                    return new Model_1.Rates(ratesData, _this).GetRates();
                                })];
                        case 2: return [2 /*return*/, _a.sent()];
                        case 3:
                            e_1 = _a.sent();
                            throw new index_1.BitPayExceptions.RateQuery(e_1);
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        try {
            // constructor with config file
            if (arguments.length > 1) {
                this._env = environment;
                this.BuildConfig(privateKey, tokens);
                this.initKeys();
                this.init();
            }
            // constructor with parameters
            else {
                this.BuildConfigFromFile(configFilePath);
                this.initKeys();
                this.init();
            }
        }
        catch (e) {
            throw new index_1.BitPayExceptions.Generic(null, "failed to initiate client : " + e.message);
        }
    }
    Client.prototype.BuildConfigFromFile = function (filePath) {
        try {
            var envConfig = void 0;
            if (fs.existsSync(filePath)) {
                try {
                    var ConfigObj = JSON.parse(fs.readFileSync(filePath))['BitPayConfiguration'];
                    this._env = ConfigObj['Environment'];
                    envConfig = ConfigObj['EnvConfig'][this._env];
                }
                catch (e) {
                    throw new index_1.BitPayExceptions.Generic(null, "Error when reading configuration file");
                }
            }
            else {
                throw new index_1.BitPayExceptions.Generic(null, "Configuration file not found");
            }
            var config = new index_1.Config();
            config.environment = this._env;
            var envTarget = {};
            envTarget[this._env] = envConfig;
            config.envConfig = envTarget;
            this._configuration = config;
        }
        catch (e) {
            throw new index_1.BitPayExceptions.Generic(null, "failed to process configuration : " + e.message);
        }
    };
    Client.prototype.BuildConfig = function (privateKey, tokens) {
        try {
            var keyHex = void 0;
            var keyFile = void 0;
            if (!fs.existsSync(privateKey)) {
                try {
                    this._ecKey = this._keyUtils.load_keypair(Buffer.from(privateKey).toString().trim());
                    keyHex = privateKey;
                }
                catch (e) {
                    throw new index_1.BitPayExceptions.Generic(null, "Private Key file not found");
                }
            }
            else {
                try {
                    keyFile = privateKey;
                }
                catch (e) {
                    throw new index_1.BitPayExceptions.Generic(null, "Could not read private Key file");
                }
            }
            var config = new index_1.Config();
            config.environment = this._env;
            var ApiTokens = tokens;
            var envConfig = {};
            envConfig["PrivateKeyPath"] = keyFile;
            envConfig["PrivateKey"] = keyHex;
            envConfig["ApiTokens"] = ApiTokens;
            var envTarget = {};
            envTarget[this._env] = envConfig;
            config.envConfig = envTarget;
            this._configuration = config;
        }
        catch (e) {
            throw new index_1.BitPayExceptions.Generic(null, "failed to process configuration : " + e.message);
        }
    };
    Client.prototype.initKeys = function () {
        if (this._ecKey == null) {
            var keyHex = void 0;
            try {
                var privateKeyPath = this._configuration.envConfig[this._env]["PrivateKeyPath"].toString().replace("\"", "");
                if (fs.existsSync(privateKeyPath)) {
                    this._ecKey = this._keyUtils.load_keypair(fs.readFileSync(privateKeyPath).toString());
                }
                else {
                    keyHex = this._configuration.envConfig[this._env]["PrivateKey"].toString().replace("\"", "");
                    if (keyHex) {
                        this._ecKey = this._keyUtils.load_keypair(Buffer.from(keyHex).toString().trim());
                    }
                }
            }
            catch (e) {
                throw new index_1.BitPayExceptions.Generic(null, "When trying to load private key. Make sure the configuration details are correct and the private key and tokens are valid : " + e.message);
            }
        }
    };
    Client.prototype.init = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        this._RESTcli = new index_1.RESTcli(this._env, this._ecKey);
                        this.LoadAccessTokens();
                        _a = this;
                        return [4 /*yield*/, this.LoadCurrencies()];
                    case 1:
                        _a._currenciesInfo = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_2 = _b.sent();
                        throw new index_1.BitPayExceptions.Generic(null, "failed to deserialize BitPay server response (Token array) : " + e_2.message);
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Client.prototype.LoadCurrencies = function () {
        return __awaiter(this, void 0, void 0, function () {
            var currenciesInfo;
            return __generator(this, function (_a) {
                try {
                    currenciesInfo = this._RESTcli.get("currencies/", {}, false).then(function (currenciesInfo) {
                        return JSON.parse(currenciesInfo);
                    });
                    return [2 /*return*/, currenciesInfo];
                }
                catch (e) {
                    // No action required
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Gets info for specific currency.
     *
     * @param currencyCode String Currency code for which the info will be retrieved.
     * @return Map|null
     */
    Client.prototype.GetCurrencyInfo = function (currencyCode) {
        return __awaiter(this, void 0, void 0, function () {
            var currencyInfo, loop;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currencyInfo = null;
                        return [4 /*yield*/, this.LoadCurrencies().then(function (ratesData) {
                                ratesData.some(function (element) {
                                    currencyInfo = element;
                                    if (element["code"] == currencyCode) {
                                        currencyInfo = element;
                                        return true;
                                    }
                                });
                            })];
                    case 1:
                        loop = _a.sent();
                        return [2 /*return*/, currencyInfo];
                }
            });
        });
    };
    Client.prototype.GetGuid = function () {
        var Min = 0;
        var Max = 99999999;
        return Min + (Math.random() * ((Max - Min) + 1)) + "";
    };
    Client.prototype.LoadAccessTokens = function () {
        try {
            this.ClearAccessTokenCache();
            this._tokenCache = this._configuration.envConfig[this._env]["ApiTokens"];
        }
        catch (e) {
            throw new index_1.BitPayExceptions.Generic(null, "When trying to load the tokens : " + e.message);
        }
    };
    Client.prototype.ClearAccessTokenCache = function () {
        this._tokenCache = index_1.Tokens;
    };
    Client.prototype.GetAccessToken = function (key) {
        try {
            return this._tokenCache[key];
        }
        catch (e) {
            throw new index_1.BitPayExceptions.Generic(null, "There is no token for the specified key : " + e.message);
        }
    };
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Client.prototype.CreateInvoice = function (invoice, facade, signRequest) {
        if (facade === void 0) { facade = index_1.Facade.Merchant; }
        if (signRequest === void 0) { signRequest = true; }
        return __awaiter(this, void 0, void 0, function () {
            var e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        invoice.guid = this.GetGuid();
                        invoice.token = this.GetAccessToken(facade);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.post("invoices", invoice, signRequest).then(function (invoiceData) {
                                return JSON.parse(invoiceData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_3 = _a.sent();
                        throw new index_1.BitPayExceptions.InvoiceCreation("failed to deserialize BitPay server response (Invoice) : " + e_3.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Client.prototype.GetInvoice = function (invoiceId, facade, signRequest) {
        if (facade === void 0) { facade = index_1.Facade.Merchant; }
        if (signRequest === void 0) { signRequest = true; }
        return __awaiter(this, void 0, void 0, function () {
            var params, e_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(facade)
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("invoices/" + invoiceId, params, signRequest).then(function (invoiceData) {
                                return JSON.parse(invoiceData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_4 = _a.sent();
                        throw new index_1.BitPayExceptions.InvoiceCreation("failed to deserialize BitPay server response (Invoice) : " + e_4.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Client.prototype.GetInvoices = function (dateStart, dateEnd, status, orderId, limit, offset) {
        if (status === void 0) { status = null; }
        if (orderId === void 0) { orderId = null; }
        if (limit === void 0) { limit = null; }
        if (offset === void 0) { offset = null; }
        return __awaiter(this, void 0, void 0, function () {
            var params, e_5;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {};
                        params["token"] = this.GetAccessToken(index_1.Facade.Merchant);
                        params["dateStart"] = dateStart;
                        params["dateEnd"] = dateEnd;
                        if (status) {
                            params["status"] = status;
                        }
                        if (orderId) {
                            params["orderId"] = orderId;
                        }
                        if (limit) {
                            params["limit"] = limit;
                        }
                        if (offset) {
                            params["offset"] = offset;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("invoices", params).then(function (invoiceData) {
                                return JSON.parse(invoiceData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_5 = _a.sent();
                        throw new index_1.BitPayExceptions.InvoiceQuery("failed to deserialize BitPay server response (Invoice) : " + e_5.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Request a BitPay Invoice Webhook.
     *
     * @param invoiceId String The id of the Invoice.
     * @return True if the webhook was successfully requested, false otherwise.
     * @throws BitPayException BitPayException class
     * @throws InvoiceQueryException InvoiceQueryException class
     */
    Client.prototype.GetInvoiceWebHook = function (invoiceId) {
        return __awaiter(this, void 0, void 0, function () {
            var invoice, e_6, params, e_7;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.GetInvoice(invoiceId)];
                    case 1:
                        invoice = _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_6 = _a.sent();
                        throw new index_1.BitPayExceptions.InvoiceQuery("Invoice with ID: " + invoiceId + " Not Found : " + e_6.message);
                    case 3:
                        params = {
                            'token': invoice.token
                        };
                        _a.label = 4;
                    case 4:
                        _a.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, this._RESTcli.post("invoices/" + invoiceId + "/notifications", params).then(function (invoiceData) {
                                var regex = /"/gi;
                                invoiceData = invoiceData.replace(regex, '');
                                return invoiceData.toLowerCase() == "success";
                            })];
                    case 5: return [2 /*return*/, _a.sent()];
                    case 6:
                        e_7 = _a.sent();
                        throw new index_1.BitPayExceptions.InvoiceQuery("failed to deserialize BitPay server response (InvoiceQuery) : " + e_7.message);
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Create a refund for a BitPay invoice.
     *
     * @param invoice     A BitPay invoice object for which a refund request should be made.  Must have been obtained using the merchant facade.
     * @param refundEmail The email of the buyer to which the refund email will be sent
     * @param amount      The amount of money to refund. If zero then a request for 100% of the invoice value is created.
     * @param currency    The three digit currency code specifying the exchange rate to use when calculating the refund bitcoin amount. If this value is "BTC" then no exchange rate calculation is performed.
     * @return True if the refund was successfully canceled, false otherwise.
     * @throws RefundCreationException RefundCreationException class
     */
    Client.prototype.CreateRefund = function (invoice, refundEmail, amount, currency) {
        return __awaiter(this, void 0, void 0, function () {
            var refund, e_8;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        refund = new Refund_1.Refund();
                        refund.token = invoice.token;
                        refund.guid = this.GetGuid();
                        refund.amount = amount;
                        refund.refundEmail = refundEmail;
                        refund.currency = currency;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.post("invoices/" + invoice.id + "/refunds", refund).then(function (refundData) {
                                return JSON.parse(refundData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_8 = _a.sent();
                        throw new index_1.BitPayExceptions.RefundCreation("failed to deserialize BitPay server response (Refund) : " + e_8.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve a previously made refund request on a BitPay invoice.
     *
     * @param invoice  The BitPay invoice having the associated refund.
     * @param refundId The refund id for the refund to be updated with new status.
     * @return A BitPay invoice object with the associated Refund object updated.
     * @throws RefundQueryException RefundQueryException class
     */
    Client.prototype.GetRefund = function (invoice, refundId) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_9;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(index_1.Facade.Merchant)
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("invoices/" + invoice.id + "/refunds/" + refundId, params).then(function (refundData) {
                                return JSON.parse(refundData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_9 = _a.sent();
                        throw new index_1.BitPayExceptions.RefundQuery("failed to deserialize BitPay server response (Refund) : " + e_9.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve all refund requests on a BitPay invoice.
     *
     * @param invoice The BitPay invoice object having the associated refunds.
     * @return A BitPay invoice object with the associated Refund objects updated.
     * @throws RefundQueryException RefundQueryException class
     */
    Client.prototype.GetRefunds = function (invoice) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_10;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': invoice.token
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("invoices/" + invoice.id + "/refunds", params).then(function (refundData) {
                                return JSON.parse(refundData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_10 = _a.sent();
                        throw new index_1.BitPayExceptions.RefundQuery("failed to deserialize BitPay server response (Refund) : " + e_10.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Cancel a previously submitted refund request on a BitPay invoice.
     *
     * @param invoice  The BitPay invoice having the associated refund to be canceled. Must have been obtained using the merchant facade.
     * @param refund The refund to be canceled.
     * @return True if the refund was successfully canceled, false otherwise.
     * @throws RefundCancellationException RefundCancellationException class
     */
    Client.prototype.CancelRefund = function (invoice, refund) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_11;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': refund.token
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.delete("invoices/" + invoice.id + "/refunds/" + refund.id, params).then(function (refundData) {
                                var regex = /"/gi;
                                refundData = refundData.replace(regex, '');
                                return refundData.toLowerCase() == "success";
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_11 = _a.sent();
                        throw new index_1.BitPayExceptions.RefundCreation("failed to deserialize BitPay server response (Refund) : " + e_11.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Create a BitPay Bill.
     *
     * @param bill        A Bill object with request parameters defined.
     * @return A BitPay generated Bill object.
     * @throws BitPayException       BitPayException class
     * @throws BillCreationException BillCreationException class
     */
    Client.prototype.CreateBill = function (bill) {
        return __awaiter(this, void 0, void 0, function () {
            var e_12;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        bill.token = this.GetAccessToken(index_1.Facade.Merchant);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.post("bills", bill).then(function (billData) {
                                return JSON.parse(billData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_12 = _a.sent();
                        throw new index_1.BitPayExceptions.BillCreation("failed to deserialize BitPay server response (Bill) : " + e_12.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve a collection of BitPay bills.
     *
     * @param status The status to filter the bills.
     * @return A list of BitPay Bill objects.
     * @throws BitPayException    BitPayException class
     * @throws BillQueryException BillQueryException class
     */
    Client.prototype.GetBills = function (status) {
        if (status === void 0) { status = null; }
        return __awaiter(this, void 0, void 0, function () {
            var params, e_13;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(index_1.Facade.Merchant)
                        };
                        if (status) {
                            params["status"] = status;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("bills", params).then(function (billData) {
                                return JSON.parse(billData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_13 = _a.sent();
                        throw new index_1.BitPayExceptions.BillQuery("failed to deserialize BitPay server response (Bill) : " + e_13.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve a BitPay bill by bill id using the specified facade.
     *
     * @param billId      The id of the bill to retrieve.
     * @return A BitPay Bill object.
     * @throws BitPayException    BitPayException class
     * @throws BillQueryException BillQueryException class
     */
    Client.prototype.GetBill = function (billId) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_14;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(index_1.Facade.Merchant)
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("bills/" + billId, params).then(function (billData) {
                                return JSON.parse(billData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_14 = _a.sent();
                        throw new index_1.BitPayExceptions.BillQuery("failed to deserialize BitPay server response (Bill) : " + e_14.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Update a BitPay Bill.
     *
     * @param bill   A Bill object with the parameters to update defined.
     * @param billId The Id of the Bill to udpate.
     * @return An updated Bill object.
     * @throws BitPayException     BitPayException class
     * @throws BillUpdateException BillUpdateException class
     */
    Client.prototype.UpdateBill = function (bill, billId) {
        return __awaiter(this, void 0, void 0, function () {
            var e_15;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this._RESTcli.update("bills/" + billId, bill).then(function (billData) {
                                return JSON.parse(billData);
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        e_15 = _a.sent();
                        throw new index_1.BitPayExceptions.BillUpdate("failed to deserialize BitPay server response (Bill) : " + e_15.message);
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Deliver a BitPay Bill.
     *
     * @param billId      The id of the requested bill.
     * @param billToken   The token of the requested bill.
     * @return A response status returned from the API.
     * @throws BillDeliveryException BillDeliveryException class
     */
    Client.prototype.DeliverBill = function (billId, billToken) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_16;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': billToken
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.post("bills/" + billId + "/deliveries", params).then(function (billData) {
                                return (JSON.parse(billData) == "Success");
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_16 = _a.sent();
                        throw new index_1.BitPayExceptions.BillDelivery("failed to deserialize BitPay server response (Bill) : " + e_16.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve a list of ledgers by date range using the merchant facade.
     *
     * @param currency  The three digit currency string for the ledger to retrieve.
     * @param dateStart The first date for the query filter.
     * @param dateEnd   The last date for the query filter.
     * @return A Ledger object populated with the BitPay ledger entries list.
     * @throws LedgerQueryException LedgerQueryException class
     */
    Client.prototype.GetLedger = function (currency, dateStart, dateEnd) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_17;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {};
                        params["token"] = this.GetAccessToken(index_1.Facade.Merchant);
                        if (currency) {
                            params["currency"] = currency;
                        }
                        if (dateStart) {
                            params["startDate"] = dateStart;
                        }
                        if (dateEnd) {
                            params["endDate"] = dateEnd;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("ledgers/" + currency, params).then(function (ledgerData) {
                                return JSON.parse(ledgerData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_17 = _a.sent();
                        throw new index_1.BitPayExceptions.LedgerQuery("failed to deserialize BitPay server response (Ledger) : " + e_17.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve a list of ledgers using the merchant facade.
     *
     * @return A list of Ledger objects populated with the currency and current balance of each one.
     * @throws LedgerQueryException LedgerQueryException class
     */
    Client.prototype.GetLedgers = function () {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_18;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {};
                        params["token"] = this.GetAccessToken(index_1.Facade.Merchant);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("ledgers", params).then(function (ledgerData) {
                                return JSON.parse(ledgerData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_18 = _a.sent();
                        throw new index_1.BitPayExceptions.LedgerQuery("failed to deserialize BitPay server response (Ledger) : " + e_18.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Submit BitPay Payout Recipients.
     *
     * @param recipients PayoutRecipients A PayoutRecipients object with request parameters defined.
     * @return array A list of BitPay PayoutRecipients objects..
     * @throws BitPayException BitPayException class
     * @throws PayoutCreationException PayoutCreationException class
     */
    Client.prototype.SubmitPayoutRecipients = function (recipients) {
        return __awaiter(this, void 0, void 0, function () {
            var e_19;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        recipients.token = this.GetAccessToken(index_1.Facade.Payroll);
                        recipients.guid = this.GetGuid();
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.post("recipients", recipients).then(function (recipientsData) {
                                return JSON.parse(recipientsData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_19 = _a.sent();
                        throw new index_1.BitPayExceptions.PayoutCreation("failed to deserialize BitPay server response (PayoutRecipients) : " + e_19.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve a collection of BitPay Payout Recipients.
     *
     * @param status String|null The recipient status you want to query on.
     * @param limit  int|null Maximum results that the query will return (useful for paging results).
     *               result).
     * @return array     A list of BitPayRecipient objects.
     * @throws BitPayException BitPayException class
     * @throws PayoutQueryException PayoutQueryException class
     */
    Client.prototype.GetPayoutRecipients = function (status, limit) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_20;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(index_1.Facade.Payroll)
                        };
                        if (status) {
                            params["status"] = status;
                        }
                        if (limit) {
                            params["limit"] = limit;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("recipients", params).then(function (recipientsData) {
                                return JSON.parse(recipientsData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_20 = _a.sent();
                        throw new index_1.BitPayExceptions.PayoutQuery("failed to deserialize BitPay server response (PayoutRecipients) : " + e_20.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve a BitPay payout recipient.
     *
     * @param recipientId String The id of the recipient to retrieve.
     * @return PayoutRecipient A BitPay PayoutRecipient object.
     * @throws BitPayException BitPayException class
     * @throws PayoutQueryException PayoutQueryException class
     */
    Client.prototype.GetPayoutRecipient = function (recipientId) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_21;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(index_1.Facade.Payroll)
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("recipients/" + recipientId, params).then(function (recipientData) {
                                return JSON.parse(recipientData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_21 = _a.sent();
                        throw new index_1.BitPayExceptions.PayoutQuery("failed to deserialize BitPay server response (PayoutRecipient) : " + e_21.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Update BitPay Payout Recipient.
     *
     * @param recipientId String The id of the recipient to update.
     * @param label String The new label for the recipient.
     * @param notificationURL String The new notificationURL for the recipient.
     * @return PayoutRecipient A BitPay PayoutRecipient object.
     * @throws BitPayException BitPayException class
     * @throws PayoutQueryException PayoutQueryException class
     */
    Client.prototype.UpdatePayoutRecipient = function (recipientId, label, notificationURL) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_22;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(index_1.Facade.Payroll)
                        };
                        if (label) {
                            params["label"] = label;
                        }
                        if (notificationURL) {
                            params["notificationURL"] = notificationURL;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.update("recipients/" + recipientId, params).then(function (recipientData) {
                                return JSON.parse(recipientData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_22 = _a.sent();
                        throw new index_1.BitPayExceptions.PayoutUpdate("failed to deserialize BitPay server response (PayoutRecipient) : " + e_22.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Cancel a previously submitted refund request on a BitPay invoice.
     *
     * @param recipientId The Payout Recipient to be deleted.
     * @return True if the recipient was successfully deleted, false otherwise.
     * @throws PayoutDeleteException PayoutDeleteException class
     */
    Client.prototype.DeletePayoutRecipient = function (recipientId) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_23;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(index_1.Facade.Payroll)
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.delete("recipients/" + recipientId, params).then(function (recipientData) {
                                return JSON.parse(recipientData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_23 = _a.sent();
                        throw new index_1.BitPayExceptions.PayoutDelete("failed to deserialize BitPay server response (PayoutRecipient) : " + e_23.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Request a BitPay payout recipient Webhook.
     *
     * @param recipientId String The id of the recipient.
     * @return True if the webhook was successfully requested, false otherwise.
     * @throws BitPayException BitPayException class
     * @throws PayoutQueryException PayoutQueryException class
     */
    Client.prototype.GetPayoutRecipientWebHook = function (recipientId) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_24;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(index_1.Facade.Payroll)
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.post("recipients/" + recipientId + "/notifications", params).then(function (recipientData) {
                                return JSON.parse(recipientData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_24 = _a.sent();
                        throw new index_1.BitPayExceptions.PayoutQuery("failed to deserialize BitPay server response (PayoutRecipient) : " + e_24.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Submit a BitPay Payout batch.
     *
     * @param batch A PayoutBatch object with request parameters defined.
     * @return A BitPay generated PayoutBatch object.
     * @throws BitPayException         BitPayException class
     * @throws PayoutCreationException PayoutCreationException class
     */
    Client.prototype.SubmitPayoutBatch = function (batch) {
        return __awaiter(this, void 0, void 0, function () {
            var currencyInfo, precision, amount, e_25;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.GetCurrencyInfo(batch.currency)];
                    case 1:
                        currencyInfo = _a.sent();
                        precision = !currencyInfo ? 2 : parseInt(currencyInfo["precision"]);
                        amount = 0.0;
                        batch.instructions.forEach(function (instruction) {
                            amount += instruction.amount;
                        });
                        batch.amount = parseFloat(amount.toFixed(precision));
                        batch.token = this.GetAccessToken(index_1.Facade.Payroll);
                        batch.guid = this.GetGuid();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this._RESTcli.post("payouts", batch).then(function (PayoutBatchData) {
                                return JSON.parse(PayoutBatchData);
                            })];
                    case 3: return [2 /*return*/, _a.sent()];
                    case 4:
                        e_25 = _a.sent();
                        throw new index_1.BitPayExceptions.PayoutCreation("failed to deserialize BitPay server response (PayoutBatch) : " + e_25.message);
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve a collection of BitPay payout batches.
     *
     * @param status The status to filter the Payout Batches.
     * @return A list of BitPay PayoutBatch objects.
     * @throws BitPayException      BitPayException class
     * @throws PayoutQueryException PayoutQueryException class
     */
    Client.prototype.GetPayoutBatches = function (status) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_26;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(index_1.Facade.Payroll)
                        };
                        if (status) {
                            params["status"] = status;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("payouts", params).then(function (payoutBatchData) {
                                return JSON.parse(payoutBatchData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_26 = _a.sent();
                        throw new index_1.BitPayExceptions.PayoutQuery("failed to deserialize BitPay server response (PayoutBatch) : " + e_26.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve a BitPay payout batch by batch id using.  The client must have been previously authorized for the payroll facade.
     *
     * @param batchId The id of the batch to retrieve.
     * @return A BitPay PayoutBatch object.
     * @throws BitPayException      BitPayException class
     * @throws PayoutQueryException PayoutQueryException class
     */
    Client.prototype.GetPayoutBatch = function (batchId) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_27;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(index_1.Facade.Payroll)
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("payouts/" + batchId, params).then(function (payoutBatchData) {
                                return JSON.parse(payoutBatchData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_27 = _a.sent();
                        throw new index_1.BitPayExceptions.PayoutQuery("failed to deserialize BitPay server response (PayoutBatch) : " + e_27.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Cancel a BitPay Payout batch.
     *
     * @param batchId The id of the batch to cancel.
     * @return A BitPay generated PayoutBatch object.
     * @throws PayoutCancellationException PayoutCancellationException class
     */
    Client.prototype.CancelPayoutBatch = function (batchId) {
        return __awaiter(this, void 0, void 0, function () {
            var batch, e_28, params, e_29;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.GetPayoutBatch(batchId)];
                    case 1:
                        batch = _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_28 = _a.sent();
                        throw new index_1.BitPayExceptions.PayoutQuery("Payout Batch with ID: " + batchId + " Not Found : " + e_28.message);
                    case 3:
                        params = {
                            'token': batch.token
                        };
                        _a.label = 4;
                    case 4:
                        _a.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, this._RESTcli.delete("payouts/" + batchId, params).then(function (payoutBatchData) {
                                return JSON.parse(payoutBatchData);
                            })];
                    case 5: return [2 /*return*/, _a.sent()];
                    case 6:
                        e_29 = _a.sent();
                        throw new index_1.BitPayExceptions.PayoutCancellation("failed to deserialize BitPay server response (PayoutBatch) : " + e_29.message);
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves settlement reports for the calling merchant filtered by query.
     * The `limit` and `offset` parameters
     * specify pages for large query sets.
     *
     * @param currency  The three digit currency string for the ledger to retrieve.
     * @param dateStart The start date for the query.
     * @param dateEnd   The end date for the query.
     * @param status    Can be `processing`, `completed`, or `failed`.
     * @param limit     Maximum number of settlements to retrieve.
     * @param offset    Offset for paging.
     * @return A list of BitPay Settlement objects.
     * @throws SettlementQueryException SettlementQueryException class
     */
    Client.prototype.GetSettlements = function (currency, dateStart, dateEnd, status, limit, offset) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_30;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {};
                        params["token"] = this.GetAccessToken(index_1.Facade.Merchant);
                        if (currency) {
                            params["currency"] = currency;
                        }
                        if (dateStart) {
                            params["dateStart"] = dateStart;
                        }
                        if (dateEnd) {
                            params["dateEnd"] = dateEnd;
                        }
                        if (currency) {
                            params["currency"] = currency;
                        }
                        if (status) {
                            params["status"] = status;
                        }
                        if (limit) {
                            params["limit"] = limit;
                        }
                        if (offset) {
                            params["offset"] = offset;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("settlements", params).then(function (settlementData) {
                                return JSON.parse(settlementData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_30 = _a.sent();
                        throw new index_1.BitPayExceptions.SettlementQuery("failed to deserialize BitPay server response (Settlement) : " + e_30.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves a summary of the specified settlement.
     *
     * @param settlementId Settlement Id.
     * @return A BitPay Settlement object.
     * @throws SettlementQueryException SettlementQueryException class
     */
    Client.prototype.GetSettlement = function (settlementId) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_31;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {};
                        params["token"] = this.GetAccessToken(index_1.Facade.Merchant);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("settlements", params).then(function (settlementData) {
                                return JSON.parse(settlementData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_31 = _a.sent();
                        throw new index_1.BitPayExceptions.SettlementQuery("failed to deserialize BitPay server response (Settlement) : " + e_31.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets a detailed reconciliation report of the activity within the settlement period.
     *
     * @param settlement Settlement to generate report for.
     * @return A detailed BitPay Settlement object.
     * @throws SettlementQueryException SettlementQueryException class
     */
    Client.prototype.GetSettlementReconciliationReport = function (settlement) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_32;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {};
                        params["token"] = settlement.token;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("settlements/" + settlement.id + "/reconciliationReport", params).then(function (settlementData) {
                                return JSON.parse(settlementData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_32 = _a.sent();
                        throw new index_1.BitPayExceptions.SettlementQuery("failed to deserialize BitPay server response (Settlement) : " + e_32.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Create a BitPay Subscription.
     *
     * @param  subscription Subscription A Subscription object with request parameters defined.
     * @return Subscription A BitPay generated Subscription object.
     * @throws SubscriptionCreationException SubscriptionCreationException class
     */
    Client.prototype.CreateSubscription = function (subscription) {
        return __awaiter(this, void 0, void 0, function () {
            var e_33;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        subscription.token = this.GetAccessToken(index_1.Facade.Merchant);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.post("subscriptions", subscription).then(function (subscriptionsData) {
                                return JSON.parse(subscriptionsData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_33 = _a.sent();
                        throw new index_1.BitPayExceptions.SubscriptionCreation("failed to deserialize BitPay server response (Subscription) : " + e_33.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve a BitPay subscription by subscription id using the specified facade.
     *
     * @param  subscriptionId string The id of the subscription to retrieve.
     * @return Subscription A BitPay Subscription object.
     * @throws BitPayException BitPayException class
     */
    Client.prototype.GetSubscription = function (subscriptionId) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_34;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(index_1.Facade.Merchant)
                        };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("subscriptions/" + subscriptionId, params).then(function (subscriptionData) {
                                return JSON.parse(subscriptionData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_34 = _a.sent();
                        throw new index_1.BitPayExceptions.SubscriptionQuery("failed to deserialize BitPay server response (Subscription) : " + e_34.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieve a collection of BitPay subscriptions.
     *
     * @param  status string|null The status to filter the subscriptions.
     * @return array A list of BitPay Subscription objects.
     * @throws BitPayException BitPayException class
     */
    Client.prototype.GetSubscriptions = function (status) {
        return __awaiter(this, void 0, void 0, function () {
            var params, e_35;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            'token': this.GetAccessToken(index_1.Facade.Merchant)
                        };
                        if (status) {
                            params["status"] = status;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._RESTcli.get("subscriptions", params).then(function (subscriptionsData) {
                                return JSON.parse(subscriptionsData);
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_35 = _a.sent();
                        throw new index_1.BitPayExceptions.SubscriptionQuery("failed to deserialize BitPay server response (Subscriptions) : " + e_35.message);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Update a BitPay Subscription.
     *
     * @param  subscription   Subscription A Subscription object with the parameters to update defined.
     * @param  subscriptionId string $subscriptionIdThe Id of the Subscription to update.
     * @return Subscription An updated Subscription object.
     * @throws BitPayException BitPayException class
     */
    Client.prototype.UpdateSubscription = function (subscription, subscriptionId) {
        return __awaiter(this, void 0, void 0, function () {
            var subscriptionObj, e_36, e_37;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.GetSubscription(subscriptionId)];
                    case 1:
                        subscriptionObj = _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_36 = _a.sent();
                        throw new index_1.BitPayExceptions.PayoutQuery("Subscription with ID: " + subscriptionId + " Not Found : " + e_36.message);
                    case 3:
                        subscription.token = subscriptionObj.token;
                        _a.label = 4;
                    case 4:
                        _a.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, this._RESTcli.update("subscriptions/" + subscriptionId, subscription).then(function (subscriptionData) {
                                return JSON.parse(subscriptionData);
                            })];
                    case 5: return [2 /*return*/, _a.sent()];
                    case 6:
                        e_37 = _a.sent();
                        throw new index_1.BitPayExceptions.SubscriptionUpdate("failed to deserialize BitPay server response (Subscription) : " + e_37.message);
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    return Client;
}());
exports.Client = Client;
//# sourceMappingURL=Client.js.map